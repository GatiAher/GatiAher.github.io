<!DOCTYPE html>
<html lang="en">
  <head>
  
   
  <title>Implementing Fast and Space-Efficient Look-up and Search</title>
  
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />
  
  
  <link rel="stylesheet" href="/css/main.css" />
    
  <noscript><link rel="stylesheet" href="/css/noscript.css" /></noscript>
  
  

<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true
        },
        options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
    };

    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function (x) {
            x.parentElement.classList += 'has-jax'
        })
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
  <link
    rel="apple-touch-icon"
    sizes="180x180"
    href="/favicon_io/apple-touch-icon.png"
  />
  <link
    rel="icon"
    type="image/png"
    sizes="32x32"
    href="/favicon_io/favicon-32x32.png"
  />
  <link
    rel="icon"
    type="image/png"
    sizes="16x16"
    href="/favicon_io/favicon-16x16.png"
  />
  <link rel="manifest" href="/favicon_io/site.webmanifest" />
  
  <meta name="generator" content="Hugo 0.108.0"> <meta property="og:title" content="Implementing Fast and Space-Efficient Look-up and Search" />
<meta property="og:description" content="The Bloom filter data structure tracks set-membership in a fast and space-efficient way. I first heard about Bloom filters when I saw them used in speeding up database search. Then, I heard about Microsoft using a stack of Bloom filters to speed up the Bing search engine&rsquo;s keyword search.
In this project, I implemented a Bloom filter and a bit-sliced document signature in C. I also wrote unit tests and a collection of fun demos to show how Bloom filters and bit-sliced signatures can be used. This report gives an overview of the project, demos and results, and notable code design decisions.

  
       
    
      Visit GitHub
    
    
  



  
       
    
      Visit Trello
    
    
  

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://GatiAher.github.io/projects/implementing-fast-and-space-efficient-look-up-and-search/" /><meta property="og:image" content="http://GatiAher.github.io/projects/implementing-fast-and-space-efficient-look-up-and-search/cover.png"/><meta property="article:section" content="projects" />
<meta property="article:published_time" content="2021-05-08T09:35:51-04:00" />
<meta property="article:modified_time" content="2021-05-08T09:35:51-04:00" />

</head>


  <body class="is-preload">
    
    
<div>
  <header id="header">
  <a href="/" class="title">Gati Aher</a>
  <nav>
    <ul>
      
      
      <li>
        <a href="http://GatiAher.github.io/categories/software-development/">Software Development (8)</a>
      </li>
      
      <li>
        <a href="http://GatiAher.github.io/categories/concepts-theory/">Concepts &amp; Theory (6)</a>
      </li>
      
      <li>
        <a href="http://GatiAher.github.io/categories/data-analysis/">Data Analysis (5)</a>
      </li>
      
      <li>
        <a href="/artwork">Art</a>
      </li>
    </ul>
  </nav>
</header>


  <div id="wrapper">
    
    <section id="single" class="wrapper">
      <header>
        <div class="single-header">
             
<a class="category" href="/categories/software-development">Software Development</a>
  

          <h1>Implementing Fast and Space-Efficient Look-up and Search</h1>
          <p>
            <i>
              written by Gati Aher on 

<time class="date" datetime="2021-05-08">May 8, 2021</time> | 21 min read <br />
                  tags:
<a href="/tags/olin-college-sp2021-software-systems-in-c">Olin College: SP2021 Software Systems in C</a>
  

            </i>
          </p>
        </div>
      </header>
      <div class="inner">
        <article><p>The Bloom filter data structure tracks set-membership in a fast and space-efficient way. I first heard about Bloom filters when I saw them used in speeding up database search. Then, I heard about Microsoft using a stack of Bloom filters to <a href="https://dl.acm.org/doi/10.1145/3077136.3080789">speed up the Bing search engine&rsquo;s keyword search</a>.</p>
<p>In this project, I implemented a Bloom filter and a bit-sliced document signature in C. I also wrote unit tests and a collection of fun demos to show how Bloom filters and bit-sliced signatures can be used. This report gives an overview of the project, demos and results, and notable code design decisions.</p>
<p><div class="center">
  <ul class="actions">
       
    <li>
      <a href="https://github.com/GatiAher/BloomForSearchFromScratch" class="button icon outline brands fa-github">Visit GitHub</a>
    </li>
    
  </ul>
</div>

<div class="center">
  <ul class="actions">
       
    <li>
      <a href="https://trello.com/b/xzVRxTDJ/bloomforsearchfromscratch" class="button icon outline brands fa-trello">Visit Trello</a>
    </li>
    
  </ul>
</div>
</p>
<div class="toc">
    <p>
        <strong>Table of Contents</strong>
    </p>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-project-goals-and-results">1 PROJECT GOALS AND RESULTS</a></li>
    <li><a href="#2-bloom-filters">2 BLOOM FILTERS</a>
      <ul>
        <li><a href="#21-demo-1-bloom-filter-to-spellcheck-a-query">2.1 Demo 1: Bloom filter to spellcheck a query</a></li>
        <li><a href="#22-demo-2-bloom-filter-to-spellcheck-a-file">2.2 Demo 2: Bloom filter to spellcheck a file</a></li>
      </ul>
    </li>
    <li><a href="#3-bit-sliced-document-signatures">3 BIT-SLICED DOCUMENT SIGNATURES</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#4-appendix">4 APPENDIX</a>
      <ul>
        <li><a href="#41-note-on-code-design">4.1 Note on Code Design</a></li>
        <li><a href="#42-note-on-controlling-false-positives">4.2 Note on Controlling False Positives</a></li>
        <li><a href="#43-note-on-choice-of-hash-function">4.3 Note on Choice of Hash Function</a></li>
      </ul>
    </li>
    <li><a href="#5-future-directions">5 FUTURE DIRECTIONS</a></li>
  </ul>
</nav>
</div>
<h2 id="1-project-goals-and-results">1 PROJECT GOALS AND RESULTS</h2>
<p>I wanted to learn about Bloom filters because I have heard about their interesting real-world applications. I particularly wanted to implement a extension of Bloom filters called bit-sliced signatures that I heard of in the talk <a href="https://www.youtube.com/watch?v=1-Xoy5w5ydM">&ldquo;BitFunnel: Revisiting Signatures for Search&rdquo; talk by Micheal Hopcroft, creator of BitFunnel</a>. This was an interesting Software Systems project because many Bloom filter implementations are done in C/C++ in order to have full control and optimization of low-level bit-wise operations</p>
<p>Thus, in terms of experience goals, I wanted to gain experience designing and using bit-wise operations, structs, function pointers, file pointers, enums, linked lists, Makefiles, writing modular code, and other programming concepts I learned about in class. (See section: <a href="#41-note-on-code-design">4.1 Note on Code Design</a> for more information about my specific coding design decisions).</p>
<p>My highest bound was implementing some of the optimizations used by Bing search engine&rsquo;s BitFunnel algorithm. However, the BitFunnel algorithm reached its best performance improvements by simply sharding its gigantic corpus intelligently (i.e. binning documents by number of unique terms) so that they could store shorter document signatures in less space but still have precision for larger documents. This design decision makes sense for a production information retrieval system that was already sharding its corpus, but makes less sense for me. Therefore, for this project I pivoted to an actionable upper bound: a set of demos that demonstrate various aspects of Bloom filters and bit-sliced signatures and provide me with an intuition of how to use them.</p>
<p>Overall, I met the higher bound for this project. I successfully implemented a Bloom filter and bit-sliced signatures, and made some really pretty and fun demos.</p>
<p><strong>Demo 1:</strong> Bloom filter spellcheck, demonstrate actions of create, add, save, query from stdin, and ability to load and add to previously saved Bloom filter</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make demo_bf_spellcheck
</span></span><span style="display:flex;"><span>make demo_bf_spellcheck_w_Gati
</span></span></code></pre></div><p><strong>Demo 2:</strong> Bloom filter to spellcheck this project&rsquo;s README file (super useful!)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make demo_bf_spellcheck_readme
</span></span></code></pre></div><p><strong>Demo 3:</strong> bit-sliced signature based document matching, retrieve list of xkcd comics that contain the keywords in a user query</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make demo_bss_xkcd_query
</span></span></code></pre></div><p>See the full <code>MakeFile</code> for more demos and list of all the executable programs. All files and programs are properly documented in the header files, and for any executable, running <code>&lt;program_name&gt; -h</code> will reveal argument details for running the program.</p>
<p><em>See test and demo output results in the <a href="https://github.com/GatiAher/BloomForSearchFromScratch/tree/main/results">results folder</a>.</em></p>
<h2 id="2-bloom-filters">2 BLOOM FILTERS</h2>
<p>The Bloom filter is a probabilistic, space-efficient data structure that can tell you whether an object is in a collection with the possibility of a false positive. It does not store the terms directly, it just stores indicators (a.k.a. hashes, probes) of each term’s presence.</p>
<figure><img src="img/Bloom_filter_example.png"
         alt="Bloom Filter"/><figcaption>
            <p>Bloom Filter</p>
        </figcaption>
</figure>

<p>False positive matches are possible, but false negatives are not: so given a query it can either return &ldquo;possibly in set&rdquo; or &ldquo;definitely not in set&rdquo;. This false positive rate can be controlled by increasing number of bits and increasing number of hash functions (See section: <a href="#42-note-on-controlling-false-positives">4.2 Note on Controlling False Positives</a>).</p>
<p>The probabilistic feature allows Bloom filters to do membership validation in very little time and very little space. So these Bloom filter lookup tables can even be stored in a browser cache without taking up a significant amount of space. In the real world, Bloom filters are used to quickly tell you if a username is taken, or to quickly check if a website is known to be malicious. They have also been used as spell-checkers and filters for censoring words. The start-up I was interning for last summer implemented a Bloom filter to speed up their database querying times by avoiding checking the database for almost all items which won&rsquo;t be found in it anyway, thus saving a lot of time and effort.</p>
<p><strong>Real World Use-Cases:</strong></p>
<p>Bitly uses a special type of Bloom filter to keep track of an ever-changing list of malicious website that they should not create links for.</p>
<ul>
<li><a href="https://github.com/bitly/dablooms">bitly/dablooms: scaling, counting, bloom filter library</a></li>
</ul>
<p>Bloom filters have also been used for tracing networks:</p>
<ul>
<li><a href="https://commerce.net/url-history-bloom-filters/">URL History Bloom Filters</a></li>
<li><a href="https://blog.cloudflare.com/when-bloom-filters-dont-bloom/">When Bloom filters don&rsquo;t bloom</a></li>
</ul>
<p>Other interesting use-cases to check out:</p>
<ul>
<li><a href="http://www.cap-lore.com/code/BloomTheory.html">Some Motley Bloom Tricks</a></li>
<li><a href="https://blog.shapesecurity.com/2018/09/26/look-ma-no-passwords-how-why-blackfish-uses-bloom-filters/">Look, Ma, No Passwords: How &amp; Why Blackfish uses Bloom Filters</a></li>
<li><a href="https://users.umiacs.umd.edu/~jimmylin/publications/Asadi_Lin_TOIS2013.pdf">Fast candidate generation for real-time tweet search with bloom filter chains</a></li>
</ul>
<p><em>I implement two demos to show the functionality of Bloom filters.</em></p>
<h3 id="21-demo-1-bloom-filter-to-spellcheck-a-query">2.1 Demo 1: Bloom filter to spellcheck a query</h3>
<p>My first demo creates a Bloom filter to check for properly spelled words. It uses a list of words from <code>/usr/share/dict/words</code>. For preprocessing, it splits terms by <code> !\&quot;#$%%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_{}|~</code>.</p>
<p>It creates and saves the Bloom filter, and then loads and uses that Bloom filter to evaluate a query from <code>stdin</code>. In the first query it highlights my name (&ldquo;Gati&rdquo;) as spelled wrong, as it was not included in the original list.</p>
<p>Since I want my spellchecker to recognize my name, I use my Bloom filter editor program to load, edit and save the Bloom filter so that it recognize my name (&ldquo;Gati&rdquo;) as a properly spelled word. Then I load and use the new Bloom filter to evaluate the query again. This time, it recognizes my name as a correctly spelled word.</p>
<figure><img src="img/output_demo_spellcheck_use_and_modify_bf.png"
         alt="Demo 1: Bloom filter spellcheck"/><figcaption>
            <p>Demo 1: Bloom filter spellcheck</p>
        </figcaption>
</figure>

<p>An important property of Bloom filters is that items can be added to it, but items cannot be removed, as deleting the set bits of a query may impact the set bits of other items.</p>
<p>The spellchecker demo adds 102401 terms, hashes each term with 13 hash functions, and stores everything in a bit signature of 2097152 bits (262KB). Using standard probability functions (explained on <a href="https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/">GeeksForGeeks</a>, also this <a href="https://hur.st/bloomfilter/?n=102401&amp;p=&amp;m=2097152&amp;k=13">calculator</a>), the saved Bloom filter I use for spellchecking has a 0.000054525 probability (1 in 18340 chance) of a false positive.</p>
<p>Furthermore, the resulting Bloom filter is ~262KB, which is 1/4th of the size of the original <code>/usr/share/dict/words</code> word list (972.4KB).</p>
<h3 id="22-demo-2-bloom-filter-to-spellcheck-a-file">2.2 Demo 2: Bloom filter to spellcheck a file</h3>
<p>My Bloom filter spellchecker can also be used to spellcheck files. I have a demo that uses my Bloom filter to spellcheck my README:</p>
<figure><img src="img/output_demo_spellcheck_README.png"
         alt="Demo 2: Bloom filter spellcheck README"/><figcaption>
            <p>Demo 2: Bloom filter spellcheck README</p>
        </figcaption>
</figure>

<p>In the screenshot you can see words flagged as incorrect highlighted in red. You can see that, in addition to flagging non-English words like &ldquo;https&rdquo; and &ldquo;murmurhash&rdquo;, it also flags words with atypical casing. For example, it believes that &ldquo;It&rdquo; is incorrect, as only &ldquo;it&rdquo; exists in its vocabulary.</p>
<p>This a super helpful tool for spellchecking my <code>README.md</code> and <code>.txt</code> files that do not have a built-in spellchecker! I can quickly read through it on my terminal and change words that are obviously spelled wrong. Using a Bloom filter as the first pass spellchecker limits the words I have to check manually, which allows me to utilize my brain power more effectively.</p>
<h2 id="3-bit-sliced-document-signatures">3 BIT-SLICED DOCUMENT SIGNATURES</h2>
<p>In addition to the Bloom filter, I also implemented a Bloom filter-based data structure called a bit-sliced signature. It that can be used to retrieve documents that contain all the words in a query.</p>
<p>A document can be represented by its document signature, which is just a Bloom filter containing all the terms in a document. If all the signatures have the same length and share a common hashing scheme, each document can be represented by a bit-sliced signature. In this approach, document signatures are stored in a big table, like a nested array of machine words (32-bit integers). Each row corresponds to one hash value. In the row, each of the 32 bits in an element correspond to 32 documents, and the bit is on or off depending on whether the document has the hash value.</p>
<figure><img src="img/bitslicedsig_example.png"
         alt="bit-sliced signature"/><figcaption>
            <p>bit-sliced signature</p>
        </figcaption>
</figure>

<p>Given a query, the program builds a query signature by hashing each term in the query with the same bag of hash functions, and then checks if any of the document signatures have all of the query hashes. If all of the query hashes are not present in the document signature, there is no possibility of the document containing all of the terms in the query. However, since sets of terms can have the same hashes, there is a possibility of falsely saying all the query terms are in the document.</p>
<p><strong>Real World Use-Cases:</strong></p>
<p>All large-scale information retrieval systems use inverted indexes for efficiently performing data retrieval based on keyword search. However, adding a new document to an inverted index requires a costly global operation to update the posting list for each term in the document. To save time on this operation, invented indexes generally use batch updates. In order to support user queries on documents that are waiting on the batch update, e.g. people searching for real-time news, Bing uses a bit-sliced signature-based data structure called BitFunnel that can ingest new documents with a quick local update while also supporting rapid keyword search.</p>
<ul>
<li><a href="https://danluu.com/bitfunnel-sigir.pdf">Goodwin, Bob, et al. “BitFunnel.” Proceedings of the 40th International ACM SIGIR Conference on Research and Development in Information Retrieval, 2017, doi:10.1145/3077136.3080789.</a></li>
</ul>
<p>Bit-sliced signatures also frequently come up in the microbiology space, in particular when performing search on bacterial or viral data sets WGS data sets.:</p>
<ul>
<li><a href="https://bigsi.readme.io/">BItsliced Genomic Signature Index [BIGSI] Docs</a></li>
</ul>
<h4 id="31-demo-3-information-retrieval-on-xkcd-comics-transcripts">3.1 Demo 3: Information retrieval on xkcd comics transcripts</h4>
<p>So as a fun information retrieval demo, I decided to use my bit-sliced document signature to retrieve <a href="https://xkcd.com/2379/">xkcd comics</a> that match keywords. This is a fun tool to explore new xkcd comics for a topic.</p>
<p>In this demo, I add 40 documents (allocating two blocks of 64 bits), use signatures of length 512, and 3 hashes on each term. Each document comprises of the title, alt-text, and transcript of a given xkcd comic. This information is scraped from <a href="https://www.explainxkcd.com">https://www.explainxkcd.com/</a> using a Python script with beautifulsoup.</p>
<p>As a demo query, I search for the term &ldquo;outside&rdquo;. This word actually appears in two documents: 30 and 14.</p>
<p>Here is an excerpt of the final <a href="https://github.com/GatiAher/BloomForSearchFromScratch/blob/main/results/output_demo_bss_xkcd_query.txt">results</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>---------------------------------
</span></span><span style="display:flex;"><span>Bit-Sliced Block Signature
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> 512, k <span style="color:#f92672">=</span> 3, num_blocks <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>39/64 docs added
</span></span><span style="display:flex;"><span>hash_seeds <span style="color:#f92672">=</span> <span style="color:#ae81ff">28</span> <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">6</span> 
</span></span><span style="display:flex;"><span>array <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>197188	0	
</span></span><span style="display:flex;"><span>16908928	8	
</span></span><span style="display:flex;"><span>1694507008	0	
</span></span><span style="display:flex;"><span>17306112	0	
</span></span><span style="display:flex;"><span>17104896	0	
</span></span><span style="display:flex;"><span>-946130846	49	
</span></span><span style="display:flex;"><span>1092625410	0	
</span></span><span style="display:flex;"><span>1611989056	0	
</span></span><span style="display:flex;"><span>-105968822	187	
</span></span><span style="display:flex;"><span>165224480	8	
</span></span><span style="display:flex;"><span>... <span style="color:#f92672">[</span>output truncated<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>colsums <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">103</span> <span style="color:#ae81ff">69</span> <span style="color:#ae81ff">23</span> <span style="color:#ae81ff">69</span> <span style="color:#ae81ff">162</span> <span style="color:#ae81ff">175</span> <span style="color:#ae81ff">82</span> <span style="color:#ae81ff">83</span> <span style="color:#ae81ff">160</span> <span style="color:#ae81ff">95</span> <span style="color:#ae81ff">68</span> <span style="color:#ae81ff">116</span> <span style="color:#ae81ff">206</span> <span style="color:#ae81ff">85</span> <span style="color:#ae81ff">89</span> 
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">324</span> <span style="color:#ae81ff">167</span> <span style="color:#ae81ff">155</span> <span style="color:#ae81ff">219</span> <span style="color:#ae81ff">263</span> <span style="color:#ae81ff">122</span> <span style="color:#ae81ff">88</span> <span style="color:#ae81ff">212</span> <span style="color:#ae81ff">428</span> <span style="color:#ae81ff">56</span> <span style="color:#ae81ff">92</span> <span style="color:#ae81ff">98</span> <span style="color:#ae81ff">88</span> <span style="color:#ae81ff">207</span> <span style="color:#ae81ff">159</span> <span style="color:#ae81ff">97</span> 
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">220</span> <span style="color:#ae81ff">71</span> <span style="color:#ae81ff">65</span> <span style="color:#ae81ff">114</span> <span style="color:#ae81ff">80</span> <span style="color:#ae81ff">122</span> <span style="color:#ae81ff">97</span> <span style="color:#ae81ff">89</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>percent filled <span style="color:#f92672">=</span> 0<span style="color:#f92672">=</span>0.00% 1<span style="color:#f92672">=</span>0.20% 2<span style="color:#f92672">=</span>0.13% 3<span style="color:#f92672">=</span>0.04% 4<span style="color:#f92672">=</span>0.13% 5<span style="color:#f92672">=</span>0.32% 6<span style="color:#f92672">=</span>0.34% 7<span style="color:#f92672">=</span>0.16% 
</span></span><span style="display:flex;"><span>8<span style="color:#f92672">=</span>0.16% 9<span style="color:#f92672">=</span>0.31% 10<span style="color:#f92672">=</span>0.19% 11<span style="color:#f92672">=</span>0.13% 12<span style="color:#f92672">=</span>0.23% 13<span style="color:#f92672">=</span>0.40% 14<span style="color:#f92672">=</span>0.17% 15<span style="color:#f92672">=</span>0.17% 
</span></span><span style="display:flex;"><span>16<span style="color:#f92672">=</span>0.63% 17<span style="color:#f92672">=</span>0.33% 18<span style="color:#f92672">=</span>0.30% 19<span style="color:#f92672">=</span>0.43% 20<span style="color:#f92672">=</span>0.51% 21<span style="color:#f92672">=</span>0.24% 22<span style="color:#f92672">=</span>0.17% 23<span style="color:#f92672">=</span>0.41% 
</span></span><span style="display:flex;"><span>24<span style="color:#f92672">=</span>0.84% 25<span style="color:#f92672">=</span>0.11% 26<span style="color:#f92672">=</span>0.18% 27<span style="color:#f92672">=</span>0.19% 28<span style="color:#f92672">=</span>0.17% 29<span style="color:#f92672">=</span>0.40% 30<span style="color:#f92672">=</span>0.31% 31<span style="color:#f92672">=</span>0.19% 
</span></span><span style="display:flex;"><span>32<span style="color:#f92672">=</span>0.43% 33<span style="color:#f92672">=</span>0.14% 34<span style="color:#f92672">=</span>0.13% 35<span style="color:#f92672">=</span>0.22% 36<span style="color:#f92672">=</span>0.16% 37<span style="color:#f92672">=</span>0.24% 38<span style="color:#f92672">=</span>0.19% 39<span style="color:#f92672">=</span>0.17% 
</span></span><span style="display:flex;"><span>40<span style="color:#f92672">=</span>0.00% 41<span style="color:#f92672">=</span>0.00% 42<span style="color:#f92672">=</span>0.00% 43<span style="color:#f92672">=</span>0.00% 44<span style="color:#f92672">=</span>0.00% 45<span style="color:#f92672">=</span>0.00% 46<span style="color:#f92672">=</span>0.00% 47<span style="color:#f92672">=</span>0.00% 
</span></span><span style="display:flex;"><span>48<span style="color:#f92672">=</span>0.00% 49<span style="color:#f92672">=</span>0.00% 50<span style="color:#f92672">=</span>0.00% 51<span style="color:#f92672">=</span>0.00% 52<span style="color:#f92672">=</span>0.00% 53<span style="color:#f92672">=</span>0.00% 54<span style="color:#f92672">=</span>0.00% 55<span style="color:#f92672">=</span>0.00% 
</span></span><span style="display:flex;"><span>56<span style="color:#f92672">=</span>0.00% 57<span style="color:#f92672">=</span>0.00% 58<span style="color:#f92672">=</span>0.00% 59<span style="color:#f92672">=</span>0.00% 60<span style="color:#f92672">=</span>0.00% 61<span style="color:#f92672">=</span>0.00% 62<span style="color:#f92672">=</span>0.00% 63<span style="color:#f92672">=</span>0.00% 
</span></span><span style="display:flex;"><span>---------------------------------
</span></span><span style="display:flex;"><span>Sucessfully saved bit-sliced signature to bss_xkcd.dat!
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;outside&#34;</span> | ./bss_play -f bss_xkcd.dat -s <span style="color:#e6db74">&#34;https://xkcd.com/%d&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span> Documents matching query: 
</span></span><span style="display:flex;"><span>https://xkcd.com/30
</span></span><span style="display:flex;"><span>https://xkcd.com/24
</span></span><span style="display:flex;"><span>https://xkcd.com/16
</span></span><span style="display:flex;"><span>https://xkcd.com/14
</span></span></code></pre></div><p>My probabilistic data structure returns 4 matches: 30, 24, 16, 14. As expected there are the two true positives and no false negatives. However, documents 16 and 24 are false positives. Upon taking a closer look, the document signatures for documents 16 and 24 are 63% and 84% full respectively. That means, each bit has a higher than random chance possibility of being flipped, so the probability of the query hash being falsely present in the signature is pretty high.</p>
<p>To reduce the rate of false positives, I can increase the length of the bit signature so that it is less full. If I was using bit-sliced signatures in a production system, there are some interesting optimizations that reduce query speed, memory usage, and false positive rate (e.g. intelligent corpus sharding, weighted Bloom filters).</p>
<p><strong>bit-sliced-signature representation in code</strong></p>
<p>Here I talk though some key logic points from <a href="https://github.com/GatiAher/BloomForSearchFromScratch/blob/main/bitslicedsig/src/bitslicedsig.c">bitslicedsig/src/bitslicedsig.c</a></p>
<p>First of all, to really understand what was going on in bitsliced signatures, I first referred to the post <a href="https://richardstartin.github.io/posts/blocked-signatures">Blocked Signatures in Java on Richard Startin&rsquo;s Blog</a>. It provided a good overview of the data structure and gave some abstract Java code to begin implementing it.</p>
<p>For my C implementation, I defined a struct to hold all the information that defined a bit-sliced signature.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">u_int32_t</span> m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">u_int32_t</span> <span style="color:#f92672">**</span>bit_matrix;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">u_int32_t</span> k;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">u_int32_t</span> <span style="color:#f92672">*</span>hash_seeds;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">u_int32_t</span> num_blocks;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">u_int32_t</span> added_d;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">bitslicedsig_t</span>;
</span></span></code></pre></div><p>The most efficient way to represent the represent the bit-sliced document signature&rsquo;s bit matrix is as a nested array. This is the initialization function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">bitslicedsig_t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bitslicedsig_create</span>(<span style="color:#66d9ef">u_int32_t</span> m, <span style="color:#66d9ef">u_int32_t</span> k, <span style="color:#66d9ef">u_int32_t</span> min_doc_capacity)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// due to integer division, this gets the minimum number of blocks to completely cover the given number of documents
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bitslicedsig<span style="color:#f92672">-&gt;</span>num_blocks <span style="color:#f92672">=</span> (min_doc_capacity <span style="color:#f92672">+</span> WORD_SIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> WORD_SIZE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// I make the bit signature a power of 2 so I can use nice bit-wise operations instead of division in later steps
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bitslicedsig<span style="color:#f92672">-&gt;</span>m <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_next_pow_2</span>(m);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// initialize row pointers, where the number of rows corresponds to the length of the bit signature.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bitslicedsig<span style="color:#f92672">-&gt;</span>bit_matrix <span style="color:#f92672">=</span> (<span style="color:#66d9ef">u_int32_t</span> <span style="color:#f92672">**</span>)<span style="color:#a6e22e">malloc</span>(bitslicedsig<span style="color:#f92672">-&gt;</span>m <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">u_int32_t</span> <span style="color:#f92672">*</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// for each row, initialize an array of 32-bit blocks, where each block corresponds to 32 documents
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> bitslicedsig<span style="color:#f92672">-&gt;</span>m; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        bitslicedsig<span style="color:#f92672">-&gt;</span>bit_matrix[i] <span style="color:#f92672">=</span> <span style="color:#a6e22e">calloc</span>(bitslicedsig<span style="color:#f92672">-&gt;</span>num_blocks, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">u_int32_t</span>));
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The main logic for both adding and querying essentially work the same way. I use a tokenizer and a while loop to turn an input into terms, and then I hash each term and set/check the corresponding bit.</p>
<p>I use modulus twice. The first fits the hash function into the proper range of my bit signature (while still keeping it random and independently distributed (see section <a href="#43-note-on-choice-of-hash-function">4.3 Note on Choice of Hash Function</a>). The second finds the proper bit to set in the block.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// turn index into a column location inside of a block location, where WORD_POW = 5 (2^5 = 32) and WORD_SIZE = 32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">u_int32_t</span> blockIndex <span style="color:#f92672">=</span> index <span style="color:#f92672">&gt;&gt;</span> WORD_POW;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">u_int32_t</span> docWord <span style="color:#f92672">=</span> <span style="color:#ae81ff">1ULL</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">mod_pow_2</span>(index, WORD_SIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">fgets</span>(buffer, bufferLength, f))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    rest <span style="color:#f92672">=</span> buffer;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ((token <span style="color:#f92672">=</span> <span style="color:#a6e22e">strtok_r</span>(rest, <span style="color:#e6db74">&#34; !</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">#$%%&amp;()*+,-./:;&lt;=&gt;?@[</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">]^_`{|}~&#34;</span>, <span style="color:#f92672">&amp;</span>rest)))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (token[<span style="color:#a6e22e">strlen</span>(token) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>)
</span></span><span style="display:flex;"><span>            token[<span style="color:#a6e22e">strlen</span>(token) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* hash each term with each hash function */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> bitslicedsig<span style="color:#f92672">-&gt;</span>k; h<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// hash the token to generate a hash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            hash <span style="color:#f92672">=</span> <span style="color:#a6e22e">murmurhash</span>(token, (<span style="color:#66d9ef">u_int32_t</span>)<span style="color:#a6e22e">strlen</span>(token), bitslicedsig<span style="color:#f92672">-&gt;</span>hash_seeds[h]);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// decide what row to set by taking hash % number of bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            hash <span style="color:#f92672">=</span> <span style="color:#a6e22e">mod_pow_2</span>(hash, bitslicedsig<span style="color:#f92672">-&gt;</span>m);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// set the bit in array by changing specific bit of specific word
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            bitslicedsig<span style="color:#f92672">-&gt;</span>bit_matrix[hash][blockIndex] <span style="color:#f92672">|=</span> docWord;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>While performing the query logic, I attempt to find an intersection of all the query hashed rows. When intersecting a set of rows, the outer loop goes over the register-sized chunks in each row and the inner loop is over the set of rows. A word mask stores the cumulative results of AND operations over the rows of a block of documents. In many cases, this word mask will become zero in the inner loop before all of the rows have been examined. Since additional intersections cannot change the result, it is possible to break out of the inner loop at this point.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// excerpt of query logic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; b <span style="color:#f92672">&lt;</span> bitslicedsig<span style="color:#f92672">-&gt;</span>num_blocks; b<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        word_mask <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; r <span style="color:#f92672">&lt;</span> bitslicedsig<span style="color:#f92672">-&gt;</span>m; r<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            isSet <span style="color:#f92672">=</span> querysig[r <span style="color:#f92672">&gt;&gt;</span> WORD_POW] <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1ULL</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">mod_pow_2</span>(r, WORD_SIZE));
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (isSet)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                word_mask <span style="color:#f92672">&amp;=</span> bitslicedsig<span style="color:#f92672">-&gt;</span>bit_matrix[r][b];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (word_mask <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// early termination of loop if no documents match
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ...
</span></span></code></pre></div><hr>
<h2 id="4-appendix">4 APPENDIX</h2>
<h3 id="41-note-on-code-design">4.1 Note on Code Design</h3>
<p>Through completing this project, I wanted to gain experience designing and using bit-wise operations, structs, function pointers, file pointers, enums, linked lists, Makefiles, and other programming concepts I learned about in class. Here are some interesting design decisions that went into writing this code:</p>
<h4 id="411--bit-wise-functions-that-take-advantage-of-powers-of-2">4.1.1  Bit-wise functions that take advantage of powers of 2</h4>
<p>Division is a very slow operation. I can avoid division in many cases by taking advantage of the fact that in base 2, dividing by 2 is equivalent to a right bit shifting.</p>
<p>This piece of knowledge is behind these two more efficient lower-level helper functions I use in my program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Returns a mod b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * b must be a power of 2 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">u_int32_t</span> <span style="color:#a6e22e">mod_pow_2</span>(<span style="color:#66d9ef">u_int32_t</span> a, <span style="color:#66d9ef">u_int32_t</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if b is 2^n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// a mod b = last n digits of a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">&amp;</span> (b <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">/** Returns power of 2 larger than n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Operates in log(log(n)) bit shifts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">u_int32_t</span> <span style="color:#a6e22e">get_next_pow_2</span>(<span style="color:#66d9ef">u_int32_t</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    n<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Divide by 2^k for consecutive doublings of k up to 32, and then OR the results.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span>    n<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The result is a number of 1 bits equal to the number of bits in the original number, plus 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// That&#39;s the next highest power of 2.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="412-function-pointers-for-cleaner-reusable-code">4.1.2 Function pointers for cleaner, reusable code</h4>
<p>I can use function wrappers with function pointers in order to reuse code and make cleaner files. In <a href="https://github.com/GatiAher/BloomForSearchFromScratch/blob/main/bloom/test/test_bloom.c">bloom/test/test_bloom.c</a> I define a wrapper function to parse string inputs into tokens in a consistent manner for insertion and querying.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">process_stream</span>(<span style="color:#66d9ef">test_results_t</span> <span style="color:#f92672">*</span>test_res, 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bloom_t</span> <span style="color:#f92672">*</span>filter, 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>operate)(<span style="color:#66d9ef">test_results_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">bloom_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>), 
</span></span><span style="display:flex;"><span>        FILE <span style="color:#f92672">*</span>stream
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">fgets</span>(buffer, bufferLength, stream))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        rest <span style="color:#f92672">=</span> buffer;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> ((token <span style="color:#f92672">=</span> <span style="color:#a6e22e">strtok_r</span>(rest, <span style="color:#e6db74">&#34; !</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">#$%%&amp;()*+,-./:;&lt;=&gt;?@[</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">]^_`{|}~&#34;</span>, <span style="color:#f92672">&amp;</span>rest)))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (token[<span style="color:#a6e22e">strlen</span>(token) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>)
</span></span><span style="display:flex;"><span>                token[<span style="color:#a6e22e">strlen</span>(token) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">operate</span>(test_res, filter, token);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// example of defined function I can use as an input
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">operate_test_add_with_warning</span>(<span style="color:#66d9ef">test_results_t</span> <span style="color:#f92672">*</span>test_res, <span style="color:#66d9ef">bloom_t</span> <span style="color:#f92672">*</span>filter, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>token);
</span></span></code></pre></div><p>This allows me to write add and lookup tests like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">/* test add */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">process_stream</span>(<span style="color:#f92672">&amp;</span>test_res, filter, operate_test_add_with_warning, options<span style="color:#f92672">-&gt;</span>fadd_to_bloom);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* test lookup */</span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">process_stream</span>(<span style="color:#f92672">&amp;</span>test_res, filter, operate_test_lookup_real_positives, options<span style="color:#f92672">-&gt;</span>fadd_to_bloom);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">process_stream</span>(<span style="color:#f92672">&amp;</span>test_res, filter, operate_test_lookup_real_negatives, options<span style="color:#f92672">-&gt;</span>fcheck_in_bloom);
</span></span></code></pre></div><h4 id="413-flexible-input-using-file-pointers">4.1.3 Flexible input using FILE pointers</h4>
<p>I want my play programs to either read input from stdin, or read from a file, like the <code>grep</code> program does. I accomplish this by allowing my bit-sliced signature files to take a FILE pointer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">queryres_t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bitslicedsig_query</span>(<span style="color:#66d9ef">bitslicedsig_t</span> <span style="color:#f92672">*</span>bitslicedsig, FILE <span style="color:#f92672">*</span>fquery);
</span></span></code></pre></div><p>This gives the play programs the flexibility of supplying either an opened file or stdin as according to the user defined flags.</p>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">## valid interaction</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;hi my name is Gati&#34;</span> | ./bf_play -f bf_spellcheck.dat -v
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## also valid interaction</span>
</span></span><span style="display:flex;"><span>./bf_play -f bf_spellcheck.dat -i README.md
</span></span></code></pre></div><h4 id="414-flexible-output-by-using-linked-lists-for-indeterminately-sized-result-arrays">4.1.4 Flexible output by Using Linked Lists for indeterminately sized result arrays</h4>
<p>The bit-sliced document signature can output a variable number of matching documents. Storing these documents efficiently is an interesting problem. My first solution involved just printing the matching document IDs out directly from inside the bitslicedsig_query function. However, this is not a good practice because it limits the format options of the displayed output. A better method would be to store the matching outputs and return a pointer to the structure. For this, I had some different options:</p>
<p>On one hand, I could store the output document IDs in an array that is the size of the maximum number of documents. However, I know that the majority of documents are not going to be matches and allotting memory for a huge array, especially if there are many documents, is not ideal.</p>
<p>My alternative solution involved using a linked list. I implement the linked list in <a href="bitslicedsig/src/queryres.c">bitslicedsig/src/queryres.c</a>. A linked list is a good choice for situations where the number of items is unknown and items are more likely to be accessed sequentially than via random access.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">queryres_t</span> <span style="color:#f92672">*</span>qr <span style="color:#f92672">=</span> <span style="color:#a6e22e">bitslicedsig_query</span>(bss, options<span style="color:#f92672">-&gt;</span>fread_input_from);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">%d Documents matching query: </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, qr<span style="color:#f92672">-&gt;</span>len);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">res_t</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> qr<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (ptr <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// here, the play program can decide the display format.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">printf</span>(options<span style="color:#f92672">-&gt;</span>output_format_string, ptr<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        ptr <span style="color:#f92672">=</span> ptr<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>By calling the program with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;outside&#34;</span> | ./bss_play -f bss_xkcd.dat -s <span style="color:#e6db74">&#34;https://xkcd.com/%d&#34;</span>
</span></span></code></pre></div><p>I can get a displayed result formatted like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ae81ff">4</span> Documents matching query: 
</span></span><span style="display:flex;"><span>https://xkcd.com/30
</span></span><span style="display:flex;"><span>https://xkcd.com/24
</span></span><span style="display:flex;"><span>https://xkcd.com/16
</span></span><span style="display:flex;"><span>https://xkcd.com/14
</span></span></code></pre></div><p>Where the document IDs are tied to a clickable url.</p>
<h4 id="415-enums-and-binary-flags-for-display-modes">4.1.5 Enums and binary flags for display modes</h4>
<p>For the bloom filter player <a href="https://github.com/GatiAher/BloomForSearchFromScratch/blob/main/bloom/demo/bf_play_main.c">bloom/demo/bf_play_main.c</a> I use enums to designate the various output modes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./bf_play -h
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt;&gt; bf_play <span style="color:#f92672">[</span>-v<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-f file_load_bloom_from<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-i file_read_input_from<span style="color:#f92672">]</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">[</span>-s mode_display_selected<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-x mode_select_in<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-h<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> 	Default: load Bloom filter from <span style="color:#e6db74">`</span>bf_saved.txt<span style="color:#e6db74">`</span>, 
</span></span><span style="display:flex;"><span>     read input from stdin, m <span style="color:#f92672">=</span> 60, k <span style="color:#f92672">=</span> 3, 
</span></span><span style="display:flex;"><span>     -s OFF <span style="color:#f92672">(</span>print all text<span style="color:#f92672">)</span>, 
</span></span><span style="display:flex;"><span>     -x OFF <span style="color:#f92672">(</span>color out-of-set terms red<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>I use an enum and binary flags to designate the options:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">## pseudocode</span>
</span></span><span style="display:flex;"><span>00 <span style="color:#f92672">=</span> ALL, OUT
</span></span><span style="display:flex;"><span>01 <span style="color:#f92672">=</span> ALL, IN
</span></span><span style="display:flex;"><span>10 <span style="color:#f92672">=</span> SELECTED, OUT
</span></span><span style="display:flex;"><span>11 <span style="color:#f92672">=</span> SELECTED, IN
</span></span></code></pre></div><p>Examples of different combinations of output formats:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./bf_play -f bf_spellcheck.dat -i README.md -x
</span></span></code></pre></div><figure><img src="img/output_demo_spellcheck_readme_x.png"
         alt="Output of demo spellcheck README option -x"/><figcaption>
            <p>Output of demo spellcheck README option -x</p>
        </figcaption>
</figure>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./bf_play -f bf_spellcheck.dat -i README.md -s
</span></span></code></pre></div><figure><img src="img/output_demo_spellcheck_readme_sx.png"
         alt="Output of demo spellcheck README option -s"/><figcaption>
            <p>Output of demo spellcheck README option -s</p>
        </figcaption>
</figure>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./bf_play -f bf_spellcheck.dat -i README.md -sx
</span></span></code></pre></div><figure><img src="img/output_demo_spellcheck_readme_sx.png"
         alt="Output of demo spellcheck README option -sx"/><figcaption>
            <p>Output of demo spellcheck README option -sx</p>
        </figcaption>
</figure>

<h4 id="416-modular-design">4.1.6 Modular Design</h4>
<p>I also wanted practice designing and writing clean, modular code. I accomplish this by making the decision to split the code for the actual data structure into a src folder (see <a href="bloom/src">bloom/src</a> and <a href="bitslicedsig/src">bitslicedsig/src</a>).</p>
<p>By encapsulating the code for the data structures, I was able to define a concrete API for the data structure and test that all the exposed functions of the API worked properly (see <a href="bloom/src">bloom/test</a> and <a href="bitslicedsig/src">bitslicedsig/test</a>).</p>
<p>After writing the test for the full end-to-end use-case, writing the demo programs was very easy; I just had to make sure the user interface was properly defined for each program and then call the appropriate data structure functions. Writing code in this way meant that my code base was reliable, predictable, and well organized. For example, my demos use an editor program and a player program. These each encapsulate a core functionality of interacting with the data structure (add and query, respectively).</p>
<p>The editor program (see <a href="bloom/demo/bf_editor_main.h">bloom/demo/bf_editor_main.h</a> and <a href="bitslicedsig/demo/bss_editor_main.h">bitslicedsig/demo/bss_editor_main.h</a>) creates a new data structure, or loads and edits an already saved data structure, and then saves the final results. This file thus uses create / load, add, and save functions of the corresponding data structure.</p>
<p>The play program (see <a href="bloom/demo/bf_play_main.h">bloom/demo/bf_play_main.h</a> and <a href="bitslicedsig/demo/bss_play_main.h">bitslicedsig/demo/bss_play_main.h</a>) loads the data structure from a file, and then processes queries from stdin or a file and displays the results in some pretty, user-customizable manner.</p>
<hr>
<h3 id="42-note-on-controlling-false-positives">4.2 Note on Controlling False Positives</h3>
<p>You can control the number of false positives (reduce collision) by increasing number of signature bits (m) and increasing number of hash functions (k).</p>
<p>The value of m configures how many bits will be allocated for the bit array. Ideally, when all the items are added, the bit array should be approximately half full. Worst case is if the bit array is completely full (all 1s), as it will say that every query may be in the filter (false positives). For performance reasons, the bit array rounds m to the nearest largest power of 2.</p>
<p>The value of k configures how many hash functions will be used in the Bloom filter hashing scheme. A higher number of hash functions means that there is a higher signal to noise ratio, where signal is the probability that a term is a member of a set given that all the term&rsquo;s probes are present in the Bloom filter, and noise is the probability of a false positive. Rarer terms have a higher likelihood of being a false positive, so increasing k improves the signal to noise ratio and allows for better retrieval of rate terms. However, a larger k leads to more hash operations, and therefore slower insertion and lookup time. The seeds of the hash function are generated with a random number generator in order to be independent and uniformly distributed.</p>
<h3 id="43-note-on-choice-of-hash-function">4.3 Note on Choice of Hash Function</h3>
<p>The hash function used in a Bloom filter must be independent, uniformly distributed, and as fast as possible. MurmurHash is a non-cryptographic hash function suitable for general hash-based lookup. In this project, I use <a href="https://fuchsia.googlesource.com/third_party/murmurhash.c/">jwerle/murmurhash</a> which implements version 3 of MurmurHash and provides 32-bit hash signatures.</p>
<p>You can try out murmurhash with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make test_murmurhash <span style="color:#f92672">&amp;&amp;</span> ./test_murmurhash
</span></span></code></pre></div><p>See expected output at <a href="results/output_test_murmurhash.txt">results/output_test_murmurhash.txt</a>.</p>
<hr>
<h2 id="5-future-directions">5 FUTURE DIRECTIONS</h2>
<p>Currently, the Bloom filter and bit-sliced signatures perform exact keyword search. However, there are situations where a fuzzier keyword search is desirable (lower precision but higher recall). Ways to make a fuzzy keyword search include:</p>
<ul>
<li>lowercasing terms before adding and and querying</li>
<li>removing &rsquo;s&rsquo; from terms so that extra space is not used to store singulars and plurals of the same word</li>
<li>using a stemmer (like <a href="https://tartarus.org/martin/PorterStemmer/">Snowball Stemmer</a>) to break terms down into their root word. In this senario, words with the same root, like &ldquo;running&rdquo;, &ldquo;runs&rdquo;, and &ldquo;ran&rdquo; would all be condensed to &ldquo;run&rdquo; before add and query.</li>
</ul>
<p>Frequently a fuzzy keyword search is not desirable because it introduces extra noise. Depending on the preprocessing, which can introduce extra time and resource costs. For this reason, Bing&rsquo;s BitFunnel algorithm does not use stemming.</p></article>
      </div>
    </section>
  </div>

  
  <footer id="footer" class="wrapper style1-alt">
  <div class="inner">
    <ul class="menu">
      <li>&copy; 2022 <a href="/">Gati Aher</a></li>
      <li>Powered by <a href="https://gohugo.io/">Hugo</a></li>
      <li>
        Adapted 
        <a href="https://html5up.net/hyperspace"
          > from HTML5 UP</a
        >
      </li>
      <li>
        Code on <a href="https://github.com/GatiAher/gatiaher-hugo">GitHub</a>
      </li>
    </ul>
  </div>
</footer>

</div>



    
    

<script src="/js/jquery.min.js"></script>

<script src="/js/jquery.scrollex.min.js"></script>

<script src="/js/jquery.scrolly.min.js"></script>

<script src="/js/browser.min.js"></script>

<script src="/js/breakpoints.min.js"></script>

<script src="/js/util.js"></script>

<script src="/js/main.js"></script>


<script src="/js/tab_control.js"></script>


<script src="/js/carousel_control.js"></script>

  </body>
</html>
